AWSTemplateFormatVersion: 2010-09-09
Description: CloudFormation for Fargate.
Resources:

  Cluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: {{ cluster.name }}

  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: {{{ cluster.logGroup }}}
      RetentionInDays: {{{ cluster.logsRetentionInDays }}}

  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: {{ cluster.name }}-{{ fargate.name }}
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      # 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB
      # 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB
      # 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB
      # 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments
      # 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments
      Cpu: 256
      # 0.5GB, 1GB, 2GB - Available cpu values: 256 (.25 vCPU)
      # 1GB, 2GB, 3GB, 4GB - Available cpu values: 512 (.5 vCPU)
      # 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB - Available cpu values: 1024 (1 vCPU)
      # Between 4GB and 16GB in 1GB increments - Available cpu values: 2048 (2 vCPU)
      # Between 8GB and 30GB in 1GB increments - Available cpu values: 4096 (4 vCPU)
      Memory: 0.5GB
      ExecutionRoleArn: !GetAtt 'ExecutionRole.Arn'
      TaskRoleArn: !GetAtt 'TaskRole.Arn'
      ContainerDefinitions:
        - Name: {{{ fargate.name }}}
          Image: {{{ fargate.image }}}:{{{ fargate.version }}}
          PortMappings:
            - ContainerPort: {{{ fargate.containerPort }}}
          # Send logs to CloudWatch Logs
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Ref LogGroup
              awslogs-stream-prefix: ecs

  # A role needed by ECS
  ExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: {{ cluster.name }}-{{ fargate.name }}-ExecutionRole
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy'

  # A role for the containers
  TaskRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: {{ fargate.name }}-TaskRole
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: {{ fargate.name }}-pod-policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
            - Effect: Allow
              Action:
                - s3:*
              Resource:
                - arn:aws:s3:::{{ fargate.bucketName }}/*
                - arn:aws:s3:::{{ fargate.bucketName }}
            - Effect: Allow
              Action:
                - logs:CreateLogStream
                - logs:PutLogEvents
                - logs:Describe*
              Resource:
                - !GetAtt 'LogGroup.Arn'

  AutoScalingRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: {{ fargate.name }}-AutoScalingRole
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceAutoscaleRole'

  ServiceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: {{ fargate.name }}-ServiceSecurityGroup
      VpcId: {{ cluster.vpc }}
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: {{ fargate.containerPort }}
          ToPort: {{ fargate.containerPort }}
          SourceSecurityGroupId: !Ref LoadBalancerSecurityGroup

  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: {{ fargate.name }}-LoadBalancerSecurityGroup
      VpcId: {{ cluster.vpc }}

  LoadBalancerSecurityGroupInHttpFromWorld:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      GroupId: !Ref LoadBalancerSecurityGroup
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80
      CidrIp: '0.0.0.0/0'

  LoadBalancerSecurityGroupInHttpsFromWorld:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      GroupId: !Ref LoadBalancerSecurityGroup
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      CidrIp: '0.0.0.0/0'

  Service:
    Type: AWS::ECS::Service
    DependsOn:
      - HttpListener
      - HttpsListener
    Properties:
      ServiceName: {{ fargate.name }}
      Cluster: !Ref Cluster
      TaskDefinition: !Ref TaskDefinition
      DeploymentConfiguration:
        MinimumHealthyPercent: 100
        MaximumPercent: 200
      DesiredCount: {{ fargate.minContainers }}
      HealthCheckGracePeriodSeconds: 10
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          Subnets:
            {{#cluster.subnets.privates}}
            - {{.}}
            {{/cluster.subnets.privates}}
          SecurityGroups:
            - !Ref ServiceSecurityGroup
      LoadBalancers:
        - ContainerName: {{ fargate.name }}
          ContainerPort: {{ fargate.containerPort }}
          TargetGroupArn: !Ref TargetGroup

  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 10
      HealthCheckPath: /health
      HealthCheckTimeoutSeconds: 5
      UnhealthyThresholdCount: 5
      HealthyThresholdCount: 5
      Port: {{ fargate.containerPort }}
      Protocol: HTTP
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: 60 # default is 300
      TargetType: ip
      VpcId: {{ cluster.vpc }}

  HttpListener:
    Type: 'AWS::ElasticLoadBalancingV2::Listener'
    Properties:
      DefaultActions:
        - Type: redirect
          RedirectConfig:
            Port: '443'
            Protocol: HTTPS
            StatusCode: 'HTTP_301'
      LoadBalancerArn: !Ref LoadBalancer
      Port: 80
      Protocol: HTTP

  HttpsListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      Certificates:
        - CertificateArn: {{{ fargate.acmCertificateArn }}}
      DefaultActions:
        - TargetGroupArn: !Ref TargetGroup
          Type: forward
      LoadBalancerArn: !Ref LoadBalancer
      Port: 443
      Protocol: HTTPS

  LoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Type: application
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: 60
        - Key: 'routing.http2.enabled'
          Value: 'true'
      Name: {{ fargate.name }}-LoadBalancer
      Scheme: internet-facing
      SecurityGroups:
        - !Ref LoadBalancerSecurityGroup
      Subnets:
        {{#cluster.subnets.publics}}
        - {{.}}
        {{/cluster.subnets.publics}}

  AutoScalingTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    DependsOn:
      - Cluster
      - Service
    Properties:
      MinCapacity: {{ fargate.minContainers }}
      MaxCapacity: {{ fargate.maxContainers }}
      ResourceId: 'service/{{ cluster.name }}/{{ fargate.name }}'
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
      RoleARN: !GetAtt AutoScalingRole.Arn

  ScaleUpPolicy:
    Type: 'AWS::ApplicationAutoScaling::ScalingPolicy'
    Properties:
      PolicyName: {{ cluster.name }}-{{ fargate.name }}-scale-up
      PolicyType: StepScaling
      ScalingTargetId: !Ref AutoScalingTarget
      StepScalingPolicyConfiguration:
        AdjustmentType: PercentChangeInCapacity
        Cooldown: 300
        MinAdjustmentMagnitude: 1
        StepAdjustments:
        - MetricIntervalLowerBound: 0
          ScalingAdjustment: 25

  ScaleDownPolicy:
    Type: 'AWS::ApplicationAutoScaling::ScalingPolicy'
    Properties:
      PolicyName: {{ cluster.name }}-{{ fargate.name }}-scale-down
      PolicyType: StepScaling
      ScalingTargetId: !Ref AutoScalingTarget
      StepScalingPolicyConfiguration:
        AdjustmentType: PercentChangeInCapacity
        Cooldown: 300
        MinAdjustmentMagnitude: 1
        StepAdjustments:
        - MetricIntervalUpperBound: 0
          ScalingAdjustment: -25

  CPUUtilizationHighAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    DependsOn:
      - Cluster
      - Service
    Properties:
      AlarmDescription: 'Service is running out of CPU'
      Namespace: 'AWS/ECS'
      Dimensions:
      - Name: ClusterName
        Value: {{ cluster.name }}
      - Name: ServiceName
        Value: {{ fargate.name }}
      MetricName: CPUUtilization
      ComparisonOperator: GreaterThanThreshold
      Statistic: Average
      Period: 300
      EvaluationPeriods: 1
      Threshold: 80
      AlarmActions:
      - !Ref ScaleUpPolicy

  CPUUtilizationLowAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    DependsOn:
      - Cluster
      - Service
    Properties:
      AlarmDescription: 'Service is wasting CPU'
      Namespace: 'AWS/ECS'
      Dimensions:
      - Name: ClusterName
        Value: {{ cluster.name }}
      - Name: ServiceName
        Value: {{ fargate.name }}
      MetricName: CPUUtilization
      ComparisonOperator: LessThanThreshold
      Statistic: Average
      Period: 300
      EvaluationPeriods: 3
      Threshold: 30
      AlarmActions:
      - !Ref ScaleDownPolicy

  DNSRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneName: {{ cluster.domainName }}.
      Name: {{ fargate.name }}.{{ cluster.domainName }}.
      Type: A
      AliasTarget:
        DNSName: !GetAtt 'LoadBalancer.DNSName'
        HostedZoneId: !GetAtt 'LoadBalancer.CanonicalHostedZoneID'

Outputs:
  Endpoint:
    Description: Endpoint
    Value: !Join ['', ['https://', !Ref DNSRecord]]
